学习笔记
这周主要学习了字符串匹配的一些算法训练，下面是我这周的学习总结

### 字符串分析算法
+ 字典树（大量高重复字符串的存储于分析）
+ KMP（在长字符串里找模式）
+ Wildcard（带通配符的字符串模式）
+ 正则（字符串通用模式匹配）
+ 状态机（通用的字符串分析）
+ LL LR（字符串多层级结构分析）

1. 字典树
用于大量高重复字符串的存储与分析，可使用场景如：自动补全，拼写检查，IP 路由 (最长前缀匹配)，T9 (九宫格) 打字预测，单词游戏等
+ 特点：
    + 最多 RR 个指向子结点的链接，其中每个链接对应字母表数据集中的一个字母。
    + 以一个终结符结尾（如Symbol("$")），终结符对应属性可记录单词出现次数，单词长度等
    + 向树中插入键时，从根开始搜索它对应于第一个键字符的链接
        + 链接存在。沿着链接移动到树的下一个子层。算法继续搜索下一个键字符
        + 链接不存在。创建一个新的节点，并将它与父节点的链接相连，该链接与当前的键字符相匹配
        + 重复以上步骤，直到到达键的最后一个字符，然后将当前节点标记为结束节点

2. KMP
用于在长字符串中找模式（部分匹配），时间复杂度(m + n)，m为源字符长度，n为模式串长度，用暴力破解法，时间复杂度为m * n，两者的不同点在于当模式串匹配不上时，模式串的一个回溯机制，暴力破解法，每当不能匹配时会将模式串指针推回到，上次主串匹配失败的下一格，而kmp则是回溯到下一次能匹配的位置。kmp最重要的一步是在于模式串重复表格的计算，如“abcabdaa”对应[0,0,0,0,1,2,0,1,1]
```
let i = 1;
let j = 0;

while(i < pattern.length) {
    if (pattern[i] === pattern[j]) {
        ++i, ++j;
        table[i] = j;
    } else {
        if(j > 0)
            j = table[j];
        else 
            ++i;
    }
}
```

3. wildcard
带通配符的字符串模式，常用语文件查找等，可以理解为只有2种通配符的简单正则，其区别在于wildcard可以在O(n)的时间复杂度或者O(m + n)的时间复杂度内解决问题
在kmp基础上加了通配符， ? 表示匹配任意字符，* 表示匹配任意个数的任意字符
处理模式串“ab*cd*abc*a?d”，我需要对第一个 * 和最后一个 * 做特殊处理，最后面的一个 * 尽可能多的去匹配，前面的 * 尽可能少的去匹配，除去第一个 * 和最后一个 * 之外，中间的 * 均可看错一个 * 加上一个字符组成一组（在字符串中找一个特定pattern的字符），“ab*cd*abc*a?b”，如找*abc，就是在原字符串中去找abc字符安（可以kmp算法），如果没有 ? 号，相当于由若干个kmp算法组成，这里为了方便，用了正则去处理，而且不是kmp去处理
```
for(let p = 0; p < startCount - 1; p ++) {
    i ++;

    // * 后面的格式
    let subpattern = "";
    while(pattern[i] !== "*") {
        subpattern += pattern[i];
        i ++;
    }

    //  将subpattern中的问号替换成正则语法（任意字符 => [\\s\\S]）
    let reg = new RegExp(subpattern.replace(/\?/g, "[\\s\\S]"), "g");

    //  将正则的lastIndex改为之前的lastIndex，这样第一个找完后，后面的可以接着去找
    reg.lastIndex = lastIndex;

    if(!reg.exec(source)) {
        return false;
    }

    lastIndex = reg.lastIndex;
}
```




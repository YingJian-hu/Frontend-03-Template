学习笔记
这一周学习了浏览器body文本解析，DOM树构建，CSS属性计算，一下是我对学习内容的一些总结

1. HTML parser模块文件拆分
实现了一个parser方法，接收一个HTML文本作为参数，返回一颗DOM树。

2. 用FSM（有限状态机）去分析HTML文本
这里作为一个toy-browser，只实现了10几个状态，原本的HTML标准中已经有明确的所有状态，可根据其状态展现的伪代码实现完整的HTML文本解析状态机

3. 解析标签，创建元素，处理属性
+ 我们把标签主要分为：开始标签，结束标签，自封闭标签
+ 在状态机中，除了状态的迁移，我们还会加入一些业务逻辑（如：在标签结束状态会去提交标签token）
+ 在属性处理的时候，属性值分为单引号，双引号，无引号三种写法，会需要较多的状态去处理，属性结束时，我们会把属性加到标签token上

4. 构建DOM树并将文本节点添加到DOM树
+ 构建技巧使用栈，遇到开始标签入栈，遇到结束标签出栈，遇到自封闭标签不入栈，最后栈里只会有一个根节点document元素，其里面保存了所有父子级元素信息。注意任何元素的父元素是它入栈前的栈定
+ 文本节点与自封闭标签处理类似，但是多个文本节点需要合并

5. 收集CSS规则
+ emit中遇到style标签，需要把CSS规则保存起来（即style标签内的文本内容）
+ 借助CSS parse解析CSS规则
+ 仔细分析CSS规则得格式，用于后面的element匹配操作

6. 添加调用
+ 当我们创建一个元素后，需要立即计算CSS
+ 理论上，当我们分析一个元素时，所有CSS规则已经收集完毕
+ 在真实浏览器中，可能遇到写在body的style标签，需要重新计算CSS，这里没有实现

7. 获取父元素序列
+ 在computeCSS函数中，必须知道元素的所有父元素才能判断元素与规则是否匹配
+ 从上一步骤stack，可以获取本元素所有的父元素。
+ 我们首先获取的是“当前元素”，所以我们获得和计算父元素匹配的顺序是由内向外的

8. 选择器和元素的匹配
+ 选择器也要由当前元素向外排列
+ 复杂选择器拆成针对单个元素的选择器，用循环匹配父元素队列

9. 计算选择器与元素匹配，生成computed属性
根据选择器的类型与元素属性，计算是否与当前元素匹配，一旦选择匹配，就应用选择器到元素上，形成computedStyle属性，这里因为是遍历，暂时会造成后面覆盖前面的样式。

10. specificity计算逻辑
+ 在生成computed时需要遵循CSS规则
+ CSS规则根据specificity和后来有限规则覆盖
+ specificity是个四元数组，越左边权重越高（[0(incline), 0(id), 0(class), 0(tagName)）
+ 一个CSS规则的specificity根据包含的所有简单选择器相加而成